## Summary
Chloroplast has experimental EcmaXml (.NET API) documentation support, but it is incomplete and awkward to integrate. This issue tracks the missing pieces required for "full" API docs support and proposes a cleaner, more automated integration with **mdoc**.

## Current State (Observed)
- API docs page notes the feature is "still in development".
- Only `<Type>` and `<Namespace>` EcmaXml roots are specially rendered (see `EcmaXmlRenderer.Render`). Other root documents (e.g. `masterdoc`, `overview`, `Libraries`, `Members`) are ignored or HTML-encoded raw.
- Navigation menu is generated ad‑hoc from `index.xml` inside `GroupContentArea` with a hard‑coded API root path segment (`/api/{assembly}`) and written to a synthesized `menu.md`.
- The mdoc execution is external (examples use a separate MSBuild project + GitHub Actions). Chloroplast does not orchestrate `mdoc update` itself.
- Limited template coverage: expects `Type.cshtml` and `Namespace.cshtml`; no first-class templates for member lists, overload grouping, assembly/overview pages, search, etc.
- Hard‑coded behavior in `GroupContentArea` (namespace file rewrite to `.../index.html`, path assumptions) instead of configurable rules.
- No symbol-level site search or intra-doc cross-link resolution logic (e.g., cref expansion) beyond what mdoc bakes into the XML.
- No handling of triple-slash doc comment edge cases (e.g., `<see>` linking to unresolved symbols produces raw text).
- No configuration keys to: set API base path, include/exclude assemblies, map assembly display names, toggle menu generation, or point to a pre-generated EcmaXml folder vs. generate on the fly.
- Error handling: unknown XML roots fall back to HTML-encoded output (not user-friendly).

## Goals
1. Provide an opinionated, one-command pipeline: `chloroplast build` (optionally) runs mdoc and then renders API docs.
2. Rich API navigation: assemblies → namespaces → types → members (grouped by kind), with breadcrumbs.
3. Configurable structure (base path, inclusion/exclusion, ordering, grouping rules, friendly titles).
4. First-class templates for overview/master pages, type pages, and member detail (including overload pages).
5. Better menu + TOC extraction without hard-coded paths.
6. Robust link generation for crefs, `see/seealso`, parameter references, type parameters.
7. Optional search index (JSON) for symbols (namespace/type/member) with lightweight client search.
8. Extensibility points: hooks/events or interface(s) to customize rendering, URL patterns, or filter symbols.
9. Clear progressive enhancement: still usable if mdoc is pre-run externally.

## Proposed Improvements / Work Items
### A. Configuration & Pipeline
- [ ] Add `api:` section in `SiteConfig.yml`, e.g.:
  ```yaml
  api:
    enabled: true
    source: ./tmp/EcmaXml            # or assemblies: ["bin/Release/net8.0/MyLib.dll"]
    runMdoc: true                    # if true, Chloroplast runs mdoc
    mdoc:
      assemblies:
        - bin/Release/net8.0/MyLib.dll
      deps:
        - ~/.nuget/packages
      out: ./tmp/EcmaXml
    basePath: /api
    includeAssemblies: ["MyLib"]     # optional filter
    excludeNamespaces: ["MyLib.Internal"]
    generateMenu: true
    searchIndex: true
  ```
- [ ] Implement an internal `IMdocRunner` service that (optionally) invokes mdoc (discover mdoc via NuGet or tool resolution) before content enumeration.
- [ ] Replace hard-coded `/api/{assembly}` path logic with config-driven base path + assembly folder naming strategy.

### B. Content Loading
- [ ] Introduce specialized `ApiContentArea` instead of overloading `GroupContentArea` with XML heuristics.
- [ ] During load, parse `masterdoc`/`overview` to build structured model (Assemblies → Namespaces → Types → Members) retained in memory for templates.
- [ ] Generate synthetic nodes for overview pages (e.g., Assemblies landing, Namespace listings) rather than relying only on physical XML files.
- [ ] Normalize URLs (e.g., `/api/{assembly}/{namespace}/` and `/api/{assembly}/{namespace}/{type}/`).
- [ ] Support overload grouping: one page per method group with anchor links for signatures.

### C. Rendering & Templates
- [ ] Create templates: `ApiOverview.cshtml`, `Assembly.cshtml`, `Namespace.cshtml` (extended), `Type.cshtml` (extended), `MemberGroup.cshtml`, `Member.cshtml`.
- [ ] Refactor `EcmaXmlRenderer` to dispatch by strongly-typed model rather than raw string prefix checks.
- [ ] Add helper services for: signature formatting (C#, maybe F#), generic parameter constraint rendering, inheritance chain, implemented interfaces, extension method listings.
- [ ] Resolve `see/seealso` crefs to site-relative links; produce warnings for unresolved references.
- [ ] Highlight code blocks with language inference.

### D. Navigation & Menus
- [ ] Replace ad-hoc `menu.md` generation with a structured navigation builder that outputs both:
  - YAML front-matter menu markdown (for legacy compatibility).
  - A JSON nav tree for dynamic client-side navigation/search.
- [ ] Provide ordering config (alphabetical, custom list, pinned groups).
- [ ] Breadcrumb component (Assembly > Namespace > Type > Member).

### E. Search & Indexing
- [ ] Build a symbol index (namespace, type full name, member signatures, keywords) to JSON.
- [ ] Client-side script to query this index (basic substring and fuzzy search) and link to pages.

### F. Mdoc Integration Enhancements
- [ ] Auto-detect when EcmaXml is stale (compare assembly timestamps vs. XML). Re-run if needed.
- [ ] Option to skip mdoc if no changes (cache key / hash of input assemblies + mdoc args).
- [ ] Expose a `chloroplast api update` command to run only the API generation phase.
- [ ] Provide structured logging + warnings (e.g., missing docs summary percentages per assembly).

### G. Error Handling & Diagnostics
- [ ] Graceful pages with explanatory text when a file/parsing error occurs (instead of raw encoded XML).
- [ ] Collect and summarize unresolved crefs, missing summaries, etc., at build end.

### H. Extensibility & Public API
- [ ] Define interfaces (e.g., `IApiModelTransformer`, `ISignatureFormatter`) and register via DI for customization.
- [ ] Document extension points in official docs.

### I. Documentation & Samples
- [ ] Update API docs guide with: new config schema, end-to-end example, GitHub Actions workflow using `runMdoc: true`.
- [ ] Provide sample repo demonstrating integrated pipeline.
- [ ] Migration notes for existing experimental setups.

### J. Backwards Compatibility / Transitional
- [ ] Maintain legacy behavior behind a feature flag (`api.legacyMode`) until new pipeline is stable.

## Acceptance Criteria
- A user can add minimal `api:` config with assembly paths and run `chloroplast build` to produce navigable API docs without manual mdoc invocation.
- Generated site includes overview, namespace, type, and member pages with working breadcrumbs and menu.
- `see`/`seealso` links resolve correctly for in-scope symbols.
- Search finds symbols by name and navigates to their pages.
- Build emits a concise summary: assemblies processed, total symbols, documented %, unresolved crefs.
- All paths configurable; no hard-coded `/api/` in code.

## Non-Goals (for this issue)
- Language-localized API docs.
- Advanced diagramming (UML, inheritance graphs) beyond basic textual hierarchy (can be future enhancements).
- Full IntelliSense-style filtering UI.

## Risks / Considerations
- Running mdoc inside Chloroplast may complicate dependency resolution (Mono vs .NET). Need a clear strategy: rely on NuGet `mdoc` package and execute its `mdoc.exe`/dll.
- Large API sets: consider performance (parallel parsing, caching model, incremental builds).

## Next Steps
1. Agree on config schema & URL patterns.
2. Implement `ApiContentArea` + model building.
3. Add internal mdoc runner (optional step gated by config).
4. Expand templates + rendering pipeline.
5. Add navigation + search index generation.
6. Write documentation & sample repo.

---
If maintainers prefer this to be split into multiple smaller issues/epics, we can break it down after consensus on scope.

Labels: enhancement, api-docs, mdoc, needs-discussion